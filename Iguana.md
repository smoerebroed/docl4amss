# Iguana #

The Okl4 kernel is a microkernel that has a minimal implementation
of features that need to have access to the CPU's supervisor mode.
It implements mechanisms (such as the ability to map a page) but
very little policy (such as what algorithm to use to find a missing
page when a page fault occurs).  The [Iguana](Iguana.md) server is a service
that runs on top of OKl4 to provide some of the services traditionally
associated with an operating system.

Iguana uses a single-address space philosophy. The [Iguana](Iguana.md)
server and all of the "normal" [Iguana](Iguana.md) processes live in a
single address space, although different processes (threads in
different "protection domains") cannot access all of the memory
in the address space with the same rights.  There is some
support for creating other address spaces, but very few
processes do.  (XXX I don't think anything in the radio baseband
image is using another address space and in fact it looks like
the kernel might be configured to have at most one address
space?)

The [Iguana](Iguana.md) server is special in that it runs as Okl4's "root
server."  This server is the first userland process started by
Okl4 and it has a special role in the system. The root server is
able to use several Okl4 system calls that other processes are
not allowed:
  * L4\_CacheControl -
  * L4\_ExchangeRegisters (when used across protection domains) - to exchange registers with another thread
  * L4\_IpcControl - to limit IPC access
  * L4\_MapControl - to map virtual memory
  * L4\_Schedule (can be used by other threads but only if they are configured as a scheduler for another thread) - to adjust scheduling
  * L4\_SpaceControl - to set up other address spaces
  * L4\_ThreadControl - to create and delete threads

All other processes must rely on [Iguana](Iguana.md) to perform these
actions on their behalf by making remote procedure calls to
[Iguana](Iguana.md) using the L4\_Ipc call.

# Weaknesses #

The [Iguana](Iguana.md) process as implemented in the radio image
does not have a complete security system. The security system
was still being developed. For example, Iguana returns
password capabilities from a number of RPCs, but the capabilities
are not fully verified in the implementation. The passwords
are also generated using a weak random number generator.

In addition, this version of Iguana supports the hardware\_back\_memsection
call which is used to ask Iguana to map physical memory for
drivers. The implementation does not restrict who can call
the RPC or what addresses can be mapped. Thus any Iguana client
can subvert the entire system.

The thread\_set\_exception call does not properly validate
its exception argument and uses it as a table index. This
allows a client to overwrite arbitrary parts of the Iguana
server memory space.

The thread method 2 (set a thread name?) copies a string
from its second argument into a 40byte buffer with no
bounds checking.  This can be cause corruption of Iguana's data
segment.

The server marshallers generated by magpie do not verify that
the number of message registers transfered in an L4\_Ipc call are
the same number expected. As a result its possible to send
less parameters to Iguana (or other RPC servers) than they
expect and the remaining arguments will be whatever is left
over from the last call. A malicious program might be able
to use this to reuse hard-to-guess capabilities sent previously
by another program. (note: the ad hoc marshallers used by
the quartz server do not check the number of registers
transfered, either).



# IDL overview #

http://code.google.com/p/docl4amss/source/browse/analysis/iguana/idl.txt



# References #
  * http://wiki.ok-labs.com/downloads/release-2.1.1-patch.9/iguana-user-manual_2.1.1.pdf - documents a version slightly newer than in the radio image, but fairly close. (Sessions are used in the 1.x tree but not documented in the 2.1.1 manual).
  * http://www.ertos.nicta.com.au/software/kenge/iguana-project/latest/ - documentation for a much older version of Iguana.